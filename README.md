# Лабораторная работа. DevSec_Threads

## Задание

Найти с помощью алгоритма полного перебора пятибуквенные пароли, соответствующие хэш-значенияи SHA-256 из текстового файла и вывести их на экран. 
+ Программа должна перебрать все возможные пароли, состоящие только из пяти строчных букв английского алфавита ASCII. 
+ Программа должна иметь возможность запуска перебора в однопоточном режиме или в многопоточном режиме (количество потоков может задаваться пользователем). Для каждого режима необходимо выводить затраченное время на подбор.

## Описание программы

Программа представляет из себя атаку методом грубой силы на хэш-функцию SHA-256. Пользователь предоставляет текстовый файл, содержащий хэши паролей, которые нужно сбрутить, и задает желаемое количество используемых потоков для перебора. Программа перебирает все возможные пароли, состоящие только из пяти строчных букв английского алфавита ASCII.

## Алгоритм работы

1. Запись в переменную `alpha` необходимых для перебора символов и чтение хэшей из файла sha.txt и в список `array`.

```python
alpha = "abcdefghijklmnopqrstuvwxyz"
with open("sha.txt") as file:
    array = [row.strip() for row in file]
```


2. Определение функции `crack_sha256_hashes(alpha_bit)`, которая принимает на вход строку `alpha_bit` (подмножество из строки `alpha`), и с помощью библиотеки `itertools` генерируются все возможные комбинации паролей из заданных символов `alpha`. Первая буква пароля - поочередно подставляемые символы из строки `alpha_bit`, последующие - поочередно подставляемые символы из всех символов `alpha`. Для каждой сгенерированной комбинации пароля вычисляется ее хэш-сумма и проверяется, присутствует ли она в списке хэшей `array`. Если находится соответствие, выводится сообщение о том, что для данного хэша было найдено его алфавитное значение.

```python
def crack_sha256_hashes(alpha_bit):
    for i in itertools.product(alpha_bit, alpha, alpha, alpha, alpha):
        if sha256(''.join(i).encode('utf-8')).hexdigest() in array:
            print('Password for the hash function ' + sha256(''.join(i).encode('utf-8')).hexdigest() + ' - ' + ''.join(i))
```


3. Определение функции input_threads(), которая запрашивает у пользователя количество потоков, которые следует использовать для выполнения задачи. Возвращается число в диапазоне от 1 до максимального количества доступных процессоров.

```python
def input_threads():
    while True:
        max_threads = mp.cpu_count()
        number = int(input(f"Enter the threads used in range [1, {max_threads}]: "))
        if number in range(1, max_threads + 1):
            return number
        else:
            print("Try again.")
```


4. Точка входа 
```python
if __name__ == '__main__':
    procs = []  # Объявление списка процессов
    threads_count = input_threads()  # Количество потоков от пользователя
    parts_count = len(alpha) // threads_count  # Количество частей, на которые будет разделена строка символов для перебора
    
    start = time.perf_counter()
    
    # Определение подмножества первых символов из строки перебора, после чего создается сам процесс перебора, куда передается
    # подмножество первых символов (alpha_bit) и вся строка (alpha). Затем созданный процесс добавляется в список процессов 
    # и запускается.
    for i in range(threads_count):   
        if i == threads_count - 1:
            bit = alpha[parts_count * i:]
        else:
            bit = alpha[parts_count * i:parts_count * (i + 1)]
        p = mp.Process(target=crack_sha256_hashes, args=(bit,)) 
        procs.append(p)
        p.start()
        
    [proc.join() for proc in procs]  # Ожидание завершения всех процессов в списке procs
    stop = time.perf_counter()
    input(f"\nThe calculation took {stop - start:0.4f} seconds, used {threads_count} thread(s).\n\nPress Enter to exit...")
```
